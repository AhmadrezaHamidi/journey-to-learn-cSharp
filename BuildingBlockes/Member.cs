using System;
using System.Collections.Generic;
using System.Data.Common;
using System.Diagnostics.Metrics;
using System.Linq;
using System.Linq.Expressions;
using System.Reflection;
using System.Reflection.Metadata;
using System.Security.Cryptography;
using System.Text;
using System.Threading.Tasks;
using System.Xml.Linq;
using static System.Net.Mime.MediaTypeNames;
using static System.Runtime.InteropServices.JavaScript.JSType;

namespace BuildingBlockes
{

    //The members of a class are either static members or instance members.
    //Static members belong to classes, and instance members belong to objects(instances of classes)



    //Constants: Constant values associated with the class
    //Fields : Variables that are associated with the class
    //Properties : Actions associated with reading and writing named properties of the class   //Properties: اقدامات مرتبط با خواندن و نوشتن ویژگی های نام کلاس
    //Methods : Actions that can be performed by the class //Methods: اقداماتی که می تواند توسط کلاس انجام شود
    //Indexers : Actions associated with indexing instances of the class like an array //Indexers: اقدامات مرتبط با نمونه های نمایه سازی کلاس مانند یک آرایه
    //Events: Notifications that can be generated by the class /Events: اعلان هایی که می تواند توسط کلاس ایجاد شود
    //Operators : Conversions and expression operators supported by the class //Operators: تبدیل ها و عملگرهای بیانی که توسط کلاس پشتیبانی می شوند
    //Constructors : Actions required to initialize instances of the class or the class itself 
    //Finalizers: Actions done before instances of the class are permanently discarded  //Finalizers: اقدامات انجام شده قبل از اینکه نمونه های کلاس برای همیشه کنار گذاشته شوند
    //Types: Nested types declared by the class //Types: انواع تودرتو اعلام شده توسط کلاس






    ////Accessibility
    //Each member of a class has an associated accessibility,
    //which controls the regions of program text that can access the member.
    //There are six possible forms of accessibility. The access modifiers are summarized below.




    //public: Access isn't limited.
    //private: Access is limited to this class.
    //protected: Access is limited to this class or classes derived from this class.
    //internal: Access is limited to the current assembly(.exe or .dll).
    //protected internal: Access is limited to this class, classes derived from this class, or classes within the same assembly.
    //private protected: Access is limited to this class or classes derived from this type within the same assembly.





    //    Fields
    //A field is a variable that is associated with a class or with an instance of a class.


    //    A field declared with the static modifier defines a static field.A static field identifies exactly one storage location.No matter
    //    how many instances of a class are created, there's only ever one copy of a static field.

    //A field declared without the static modifier defines an instance field.Every instance of a class contains a separate copy of all the instance fields of that class.






    //Methods
    //A method is a member that implements a computation or action that can be performed by an object or class. Static methods are accessed through the class. Instance methods are accessed through instances of the class.
    //Methods may have a list of parameters, which represent values or variable references passed to the method.Methods have a return type, which specifies the type of the value computed and returned by the method.A method's return type is void if it doesn't return a value.
    //Like types, methods may also have a set of type parameters, for which type arguments must be specified when the method is called.Unlike types, the type arguments can often be inferred from the arguments of a method call and need not be explicitly given.
    //The signature of a method must be unique in the class in which the method is declared.The signature of a method consists of the name of the method, the number of type parameters, and the number, modifiers, and types of its parameters.The signature of a method doesn't include the return type.
    //When a method body is a single expression, the method can be defined using a compact expression format, as shown in the following example:
    //public override string ToString() => "This is an object";
    //}

    //    ع
    //تابع یک عضوی است که یک محاسبه یا عملی را پیاده‌سازی می‌کند که توسط یک شی یا کلاس انجام می‌شود.توابع استاتیک از طریق کلاس دسترسی داده می‌شوند.توابع نمونه‌ای از طریق نمونه‌های کلاس دسترسی داده می‌شوند.
    //توابع ممکن است یک لیست از پارامترها داشته باشند که مقادیر یا مراجع متغیری را که به تابع منتقل می‌شوند، نمایان می‌کنند. توابع دارای یک نوع بازگشتی هستند که نوع مقدار محاسبه شده و بازگشت داده شده توسط تابع را مشخص می‌کند. نوع بازگشتی تابع، "void" است اگر مقداری را بازگشت ندهد.
    //مانند انواع داده، توابع هم می‌توانند دارای یک مجموعه از پارامترهای نوع باشند که باید هنگام فراخوانی تابع، آرگومان‌های نوع مشخصی برای آن داده شوند.بر خلاف انواع داده، معمولاً می‌توان نوع‌های آرگومان از طریق آرگومان‌های یک تماس تابع استخراج شده و نیازی به اعلام صریح آنها نیست.
    //امضای یک تابع باید در کلاسی که تابع در آن اعلام می‌شود، یکتا باشد. امضای یک تابع شامل نام تابع، تعداد پارامترهای نوعی و تعداد، اصلاحگرها و انواع پارامترهای آن می‌شود. امضای یک تابع شامل نوع بازگشتی نمی‌شود.
    //وقتی بدنه یک تابع یک عبارت تنهاست، می‌توان تابع را با یک فرمت عبارت فشرده تعریف کرد،


    //Parameters
    //Parameters are used to pass values
    //or variable references to methods.The parameters of a method get their actual values from the arguments that are specified when the method is invoked.
    //There are four kinds of parameters: value parameters, reference parameters, output parameters, and parameter arrays.



    //A value parameter is used for passing input arguments.A value parameter corresponds to a local variable that gets
    //its initial value from the argument that was passed for the parameter.Modifications to a value parameter don't affect the argument that was passed for the parameter.
    //    //Value parameters can be optional, by specifying a default value so that corresponding arguments can be omitted.
    //    یک پارامتر مقداری برای ارسال آرگومان‌های ورودی استفاده می‌شود.یک پارامتر مقداری متناظر با یک متغیر محلی است که مقدار اولیه خود را از آرگومانی که برای پارامتر ارسال شده، می‌گیرد.تغییرات اعمال شده به یک پارامتر مقداری بر روی آرگومانی که برای پارامتر ارسال شده است، تأثیری نمی‌گذارد.

    //پارامترهای مقداری می‌توانند اختیاری باشند، با تعیین یک مقدار پیش‌فرض، به‌طوری که آرگومان‌های متناظر می‌توانند حذف شوند.

    // تعریف تابع با پارامترهای مقداری و پیش‌فرض
    //static void GreetUser(string name = "Guest")
    //{
    //    Console.WriteLine($"Hello, {name}!");
    //}

    //static void Main()
    //{
    //    // فراخوانی تابع بدون ارسال آرگومان
    //    GreetUser();  // خروجی: Hello, Guest!

    //    // فراخوانی تابع با ارسال آرگومان مشخص
    //    GreetUser("Alice");  // خروجی: Hello, Alice!
    //}


    //A reference parameter is used for passing arguments by reference.The argument passed for a reference parameter must be a variable with a definite value.During execution of the method, the reference parameter represents the same storage location as the argument variable.A reference parameter is declared with the ref modifier.The following example shows the use of ref parameters.

    //    یک پارامتر مرجعی برای ارسال آرگومان‌ها به صورت مرجعی(by reference) استفاده می‌شود.آرگومانی که برای یک پارامتر مرجعی ارسال می‌شود، باید یک متغیر با مقدار معین باشد.در طول اجرای تابع، پارامتر مرجعی نمایانگر همان مکان ذخیره‌سازی می‌شود که متغیر آرگومان دارد.یک پارامتر مرجعی با استفاده از ویژگی "ref" اعلام می‌شود. مثال زیر نحوه استفاده از پارامترهای مرجعی را نشان می‌دهد:

    //```csharp
    //using System;

    //class Program
    //    {
    //        // تعریف تابع با پارامتر مرجعی
    //        static void UpdateValue(ref int number)
    //        {
    //            number = number * 2;
    //        }

    //        static void Main()
    //        {
    //            int value = 5;

    //            Console.WriteLine($"Before calling UpdateValue: {value}");  // خروجی: Before calling UpdateValue: 5

    //            // فراخوانی تابع با استفاده از پارامتر مرجعی
    //            UpdateValue(ref value);

    //            Console.WriteLine($"After calling UpdateValue: {value}");  // خروجی: After calling UpdateValue: 10
    //        }
    //    }
    //```

    //در این مثال، ما تابعی به نام "UpdateValue" ایجاد کرده‌ایم که یک پارامتر مرجعی به نام "number" دارد
    //.وقتی تابع "UpdateValue" فراخوانی می‌شود، متغیر "value" به عنوان آرگومان به تابع ارسال می‌شود و از آنجا که "number" به عنوان یک پارامتر مرجعی اعلام شده است، تغییراتی که در داخل تابع بر روی "number" اعمال می‌شود، به متغیر "value" هم انتقال پیدا می‌کند.به این ترتیب، مقدار "value" پس از فراخوانی تابع "UpdateValue" تغییر کرده و مقدار جدید 10 است.



    //static void Swap(ref int x, ref int y)
    //{
    //    int temp = x;
    //    x = y;
    //    y = temp;
    //}

    //public static void SwapExample()
    //{
    //    int i = 1, j = 2;
    //    Swap(ref i, ref j);
    //    Console.WriteLine($"{i} {j}");    // "2 1"
    //}





    //An output parameter is used for passing arguments by reference.
    //It's similar to a reference parameter, except that it doesn't require that you explicitly assign a value to the caller-provided argument.
    //An output parameter is declared with the out modifier.The following example shows the use of out parameters.
    //یک پارامتر خروجی برای ارسال آرگومان ها توسط مرجع استفاده می شود.این شبیه به یک پارامتر مرجع است، با این تفاوت که نیازی به اختصاص یک مقدار به آرگومان ارائه شده توسط تماس گیرنده ندارد.یک پارامتر خروجی با اصلاح کننده out اعلام می شود.مثال زیر استفاده از پارامترهای out را نشان می دهد.


    //static void Divide(int x, int y, out int quotient, out int remainder)
    //{
    //    quotient = x / y;
    //    remainder = x % y;
    //}

    //public static void OutUsage()
    //{
    //    Divide(10, 3, out int quo, out int rem);
    //    Console.WriteLine($"{quo} {rem}");  // "3 1"
    //}





    //public class Console
    //{
    //    public static void Write(string fmt, params object[] args) { }
    //    public static void WriteLine(string fmt, params object[] args) { }
    //    // ...
    //}


    //    Method body and local variables
    //A method's body specifies the statements to execute when the method is invoked.

    //A method body can declare variables that are specific to the invocation of the method.Such variables are called local variables.A local variable declaration specifies a type name, a variable name, and possibly an initial value.The following example
    //    declares a local variable i with an initial value of zero and a local variable j with no initial value.

    //class Squares
    //{
    //    public static void WriteSquares()
    //    {
    //        int i = 0;
    //        int j;
    //        while (i < 10)
    //        {
    //            j = i * i;
    //            Console.WriteLine($"{i} x {i} = {j}");
    //            i++;
    //        }
    //    }
    //}








    //Static and instance methods


//    A method declared with a static modifier is a static method.A static method doesn't operate on a specific instance and can only directly access static members.

//        یک تابعی که با افزودن مدیفایر static تعریف شود، یک تابع استاتیک(static method) است.تابع استاتیک بر روی یک نمونه خاص عمل نمی‌کند و تنها به صورت مستقیم به اعضای استاتیک دسترسی دارد.به عبارت دیگر، تابع استاتیک متعلق به کلاس خود است و نه به نمونه‌هایی که از آن کلاس ایجاد می‌شوند.

//توجه کنید که توابع استاتیک معمولاً برای انجام عملیاتی که به خصوص به نمونه‌های خاص کلاس مرتبط نیستند و عملیات کلی کلاس را تحت پوشش قرار می‌دهند، استفاده می‌شوند.به عنوان مثال، یک تابع استاتیک می‌تواند برای انجام محاسبات ریاضی ساده، تبدیل داده‌ها یا انجام تعدادی کارهای عمومی دیگر به کار رود.از آنجا که تابع استاتیک به نمونه‌های خاص مرتبط نیست، می‌توان به صورت مستقل از ایجاد نمونه از کلاس، به توابع استاتیک دسترسی داشت.

